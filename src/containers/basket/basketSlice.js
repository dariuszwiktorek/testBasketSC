import { createAsyncThunk, createSlice } from '@reduxjs/toolkit';
import { fetchCount } from './basketAPI';
import { v4 as uuidv4 } from 'uuid';


const vatMultiper = .2;
const pricePrefix = "Â£";
// stored by unique identifiers 
const productsData =  {
  [uuidv4()]: {name:"Apple", unitPrice:0.52, quantity:2},
  [uuidv4()]: {name:"Banana", unitPrice:0.67, quantity:3},
  [uuidv4()]: {name:"Cinamon", unitPrice:0.99, quantity:1},
  [uuidv4()]: {name:"Dill", unitPrice:1.09, quantity:4},
  [uuidv4()]: {name:"Eggplant", unitPrice:2.51, quantity:5}
}

const updateProductRecord = (product, quantity) => {

  if(!quantity) quantity = product.quantity;

  return  {...product, 
          unitPrice:product.unitPrice, 
          quantity:quantity, 
          cost: safeMultyply(product.unitPrice, quantity),
  }
}

const safeAdd = (vA, vB) => {
  const a = Math.round(vA*100);
	const b = Math.round(vB*100);
	return (a+b)/100;
}

const safeMultyply = (vA, vB) => {
  const a = Math.round(vA*100);
	const b = Math.round(vB*100);
	return (a*b)/10000;
}

const initialState =  Object.entries(productsData).reduce((prev, [key, value])=>{
  prev.products[key] = updateProductRecord(value);
  prev.total = safeAdd(prev.total, prev.products[key].cost);
  prev.vat = safeAdd(prev.vat, safeMultyply(prev.products[key].cost, vatMultiper));
  prev.subtotal = safeAdd(prev.total, -prev.vat);
  return prev;
}, {products:{}, total:0, vat:0, subtotal:0, pricePrefix:pricePrefix})

const calcTotal = (products) => {
  return Object.entries(products).reduce((prev, [key, value])=>{ return safeAdd(prev, value.cost);}, 0);
}

export const incrementAsync = createAsyncThunk(
  'counter/fetchCount',
  async (amount) => {
    const response = await fetchCount(amount);
    // The value we return becomes the `fulfilled` action payload
    return response.data;
  }
);

export const basketSlice = createSlice({
  name: 'basket',
  initialState,
  reducers: {
    updateQuantity: (state, action) => {
      const uid = action.payload.uid;
      const newQuantity = action.payload.value;
      if(newQuantity > 0 && newQuantity<=10) {
        state.products[uid] = updateProductRecord(state.products[uid], newQuantity);
        state.total = calcTotal(state.products);
        state.vat = safeMultyply( state.total, vatMultiper);
        state.subtotal = safeAdd( state.total, -state.vat );
      }
    },
    deleteProduct: (state, action) => {
      delete state.products[action.payload.uid];
      state.total = calcTotal(state.products);
      state.vat = safeMultyply( state.total, vatMultiper);
      state.subtotal = safeAdd( state.total, -state.vat );
    },
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {
    builder
      .addCase(incrementAsync.pending, (state) => {
        state.status = 'loading';
      })
      .addCase(incrementAsync.fulfilled, (state, action) => {
        state.status = 'idle';
        state.value += action.payload;
      });
  },
});

export const { increment, decrement, incrementByAmount, updateQuantity, deleteProduct } = basketSlice.actions;

// The function below is called a selector and allows us to select a value from
// the state. Selectors can also be defined inline where they're used instead of
// in the slice file. For example: `useSelector((state: RootState) => state.counter.value)`
export const selectBasket = (state) => state.basket;


export default basketSlice.reducer;
