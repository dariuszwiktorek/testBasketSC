import { createAsyncThunk, createSlice } from '@reduxjs/toolkit';
import { postBasket } from './basketAPI';
import { v4 as uuidv4 } from 'uuid';

//TODO: This needs refactoring

const vatMultiper = .2;
const pricePrefix = "Â£";
// stored by unique identifiers 
const productsData = {
  [uuidv4()]: { name: "Apple", unitPrice: 0.52, quantity: 2 },
  [uuidv4()]: { name: "Banana", unitPrice: 0.67, quantity: 3 },
  // [uuidv4()]: { name: "Cinamon", unitPrice: 0.99, quantity: 1 },
  // [uuidv4()]: { name: "Dill", unitPrice: 1.09, quantity: 4 },
  // [uuidv4()]: { name: "Eggplant", unitPrice: 2.51, quantity: 5 }
}

const updateProductRecord = (product, quantity) => {

  if (!quantity) quantity = product.quantity;

  return {
    ...product,
    unitPrice: product.unitPrice,
    quantity: quantity,
    cost: safeMultyply(product.unitPrice, quantity),
  }
}

const safeAdd = (vA, vB) => {
  const a = Math.round(vA * 100);
  const b = Math.round(vB * 100);
  return (a + b) / 100;
}

const safeMultyply = (vA, vB) => {
  const a = Math.round(vA * 100);
  const b = Math.round(vB * 100);
  return (a * b) / 10000;
}

const initialState = Object.entries(productsData).reduce((prev, [key, value]) => {
  prev.products[key] = updateProductRecord(value);
  prev.total = safeAdd(prev.total, prev.products[key].cost);
  prev.vat = safeAdd(prev.vat, safeMultyply(prev.products[key].cost, vatMultiper));
  prev.subtotal = safeAdd(prev.total, -prev.vat);
  prev.itemCount++;
  return prev;
}, { products: {}, status:"idle", total: 0, vat: 0, subtotal: 0, pricePrefix: pricePrefix, itemCount: 0 })

const calcTotal = (products) => {
  return Object.entries(products).reduce((prev, [key, value]) => {
    prev.itemsCount++;
    prev.total = safeAdd(prev.total, value.cost);
    return prev;
  },
    { total: 0, itemsCount: 0 });
}

export const buyNow = createAsyncThunk(
  'basket/buyNow',
  async (products) => {
    const response = await postBasket(products);
    // The value we return becomes the `fulfilled` action payload
    return response.data;
  }
);

export const basketSlice = createSlice({
  name: 'basket',
  initialState,
  reducers: {
    updateQuantity: (state, action) => {
      const uid = action.payload.uid;
      const newQuantity = action.payload.value;
      if (newQuantity > 0 && newQuantity <= 10) {
        state.products[uid] = updateProductRecord(state.products[uid], newQuantity);
        const res = calcTotal(state.products);
        state.total = res.total;
        state.itemsCount = res.itemsCount;
        state.vat = safeMultyply(state.total, vatMultiper);
        state.subtotal = safeAdd(state.total, -state.vat);
      }
    },
    deleteProduct: (state, action) => {
      delete state.products[action.payload.uid];
      const res = calcTotal(state.products);
      state.total = res.total;
      state.itemsCount = res.itemsCount;
      state.vat = safeMultyply(state.total, vatMultiper);
      state.subtotal = safeAdd(state.total, -state.vat);
    },
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {
    builder
      .addCase(buyNow.pending, (state) => {
        state.status = 'loading';
      })
      .addCase(buyNow.fulfilled, (state, action) => {
        state.status = 'done';
        state.products = {};
        state.itemCount = 0;
        state.total = 0;
        state.vat = 0; 
        state.subtotal = 0;
        // state.value += action.payload;
      });
  },
});

export const {updateQuantity, deleteProduct } = basketSlice.actions;

// The function below is called a selector and allows us to select a value from
// the state. Selectors can also be defined inline where they're used instead of
// in the slice file. For example: `useSelector((state: RootState) => state.counter.value)`
export const selectBasket = (state) => state.basket;


export default basketSlice.reducer;
